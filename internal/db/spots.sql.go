// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: spots.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const createSpot = `-- name: CreateSpot :one
INSERT INTO spots (
    piece_id,
    id,
    name,
    idx,
    stage,
    audio_prompt_url,
    image_prompt_url,
    notes_prompt,
    text_prompt,
    current_tempo,
    measures,
    stage_started
) VALUES (
    (SELECT pieces.id FROM pieces WHERE pieces.user_id = ? AND pieces.id = ? LIMIT 1),
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    unixepoch('now')
)
RETURNING id, piece_id, name, idx, stage, measures, audio_prompt_url, image_prompt_url, notes_prompt, text_prompt, current_tempo, last_practiced, stage_started, priority
`

type CreateSpotParams struct {
	UserID         string         `json:"userId"`
	PieceID        string         `json:"pieceId"`
	ID             string         `json:"id"`
	Name           string         `json:"name"`
	Idx            int64          `json:"idx"`
	Stage          string         `json:"stage"`
	AudioPromptUrl string         `json:"audioPromptUrl"`
	ImagePromptUrl string         `json:"imagePromptUrl"`
	NotesPrompt    string         `json:"notesPrompt"`
	TextPrompt     string         `json:"textPrompt"`
	CurrentTempo   sql.NullInt64  `json:"currentTempo"`
	Measures       sql.NullString `json:"measures"`
}

func (q *Queries) CreateSpot(ctx context.Context, arg CreateSpotParams) (Spot, error) {
	row := q.db.QueryRowContext(ctx, createSpot,
		arg.UserID,
		arg.PieceID,
		arg.ID,
		arg.Name,
		arg.Idx,
		arg.Stage,
		arg.AudioPromptUrl,
		arg.ImagePromptUrl,
		arg.NotesPrompt,
		arg.TextPrompt,
		arg.CurrentTempo,
		arg.Measures,
	)
	var i Spot
	err := row.Scan(
		&i.ID,
		&i.PieceID,
		&i.Name,
		&i.Idx,
		&i.Stage,
		&i.Measures,
		&i.AudioPromptUrl,
		&i.ImagePromptUrl,
		&i.NotesPrompt,
		&i.TextPrompt,
		&i.CurrentTempo,
		&i.LastPracticed,
		&i.StageStarted,
		&i.Priority,
	)
	return i, err
}

const deleteSpot = `-- name: DeleteSpot :exec
DELETE FROM spots
WHERE spots.id = ?1 AND spots.piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type DeleteSpotParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

func (q *Queries) DeleteSpot(ctx context.Context, arg DeleteSpotParams) error {
	_, err := q.db.ExecContext(ctx, deleteSpot, arg.SpotID, arg.UserID, arg.PieceID)
	return err
}

const deleteSpotsExcept = `-- name: DeleteSpotsExcept :exec
DELETE FROM spots
WHERE
spots.piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?1 AND pieces.id = ?2 LIMIT 1)
AND spots.id NOT IN (/*SLICE:spotIDs*/?)
`

type DeleteSpotsExceptParams struct {
	UserID  string   `json:"userId"`
	PieceID string   `json:"pieceId"`
	SpotIDs []string `json:"spotIDs"`
}

func (q *Queries) DeleteSpotsExcept(ctx context.Context, arg DeleteSpotsExceptParams) error {
	query := deleteSpotsExcept
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	queryParams = append(queryParams, arg.PieceID)
	if len(arg.SpotIDs) > 0 {
		for _, v := range arg.SpotIDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:spotIDs*/?", strings.Repeat(",?", len(arg.SpotIDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:spotIDs*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const demoteSpotToExtraRepeat = `-- name: DemoteSpotToExtraRepeat :exec
UPDATE spots
SET
    stage = CASE WHEN stage != 'extra_repeat' AND stage != 'repeat' THEN 'extra_repeat' ELSE stage END,
    stage_started = CASE WHEN stage != 'extra_repeat' AND stage != 'repeat' THEN unixepoch('now') ELSE stage_started END,
    last_practiced = unixepoch('now')
WHERE spots.id = ?1 AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type DemoteSpotToExtraRepeatParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

func (q *Queries) DemoteSpotToExtraRepeat(ctx context.Context, arg DemoteSpotToExtraRepeatParams) error {
	_, err := q.db.ExecContext(ctx, demoteSpotToExtraRepeat, arg.SpotID, arg.UserID, arg.PieceID)
	return err
}

const getSpot = `-- name: GetSpot :one
SELECT
    spots.id, spots.piece_id, spots.name, spots.idx, spots.stage, spots.measures, spots.audio_prompt_url, spots.image_prompt_url, spots.notes_prompt, spots.text_prompt, spots.current_tempo, spots.last_practiced, spots.stage_started, spots.priority,
    pieces.title AS piece_title
FROM spots
INNER JOIN pieces ON pieces.id = spots.piece_id
WHERE spots.id = ?1 AND spots.piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type GetSpotParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

type GetSpotRow struct {
	ID             string         `json:"id"`
	PieceID        string         `json:"pieceId"`
	Name           string         `json:"name"`
	Idx            int64          `json:"idx"`
	Stage          string         `json:"stage"`
	Measures       sql.NullString `json:"measures"`
	AudioPromptUrl string         `json:"audioPromptUrl"`
	ImagePromptUrl string         `json:"imagePromptUrl"`
	NotesPrompt    string         `json:"notesPrompt"`
	TextPrompt     string         `json:"textPrompt"`
	CurrentTempo   sql.NullInt64  `json:"currentTempo"`
	LastPracticed  sql.NullInt64  `json:"lastPracticed"`
	StageStarted   sql.NullInt64  `json:"stageStarted"`
	Priority       int64          `json:"priority"`
	PieceTitle     string         `json:"pieceTitle"`
}

func (q *Queries) GetSpot(ctx context.Context, arg GetSpotParams) (GetSpotRow, error) {
	row := q.db.QueryRowContext(ctx, getSpot, arg.SpotID, arg.UserID, arg.PieceID)
	var i GetSpotRow
	err := row.Scan(
		&i.ID,
		&i.PieceID,
		&i.Name,
		&i.Idx,
		&i.Stage,
		&i.Measures,
		&i.AudioPromptUrl,
		&i.ImagePromptUrl,
		&i.NotesPrompt,
		&i.TextPrompt,
		&i.CurrentTempo,
		&i.LastPracticed,
		&i.StageStarted,
		&i.Priority,
		&i.PieceTitle,
	)
	return i, err
}

const getSpotStageStarted = `-- name: GetSpotStageStarted :one
SELECT
    stage_started,
    stage
FROM spots
WHERE spots.id = ?1 AND spots.piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
LIMIT 1
`

type GetSpotStageStartedParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

type GetSpotStageStartedRow struct {
	StageStarted sql.NullInt64 `json:"stageStarted"`
	Stage        string        `json:"stage"`
}

func (q *Queries) GetSpotStageStarted(ctx context.Context, arg GetSpotStageStartedParams) (GetSpotStageStartedRow, error) {
	row := q.db.QueryRowContext(ctx, getSpotStageStarted, arg.SpotID, arg.UserID, arg.PieceID)
	var i GetSpotStageStartedRow
	err := row.Scan(&i.StageStarted, &i.Stage)
	return i, err
}

const listHighPrioritySpots = `-- name: ListHighPrioritySpots :many
SELECT
    spots.id, spots.piece_id, spots.name, spots.idx, spots.stage, spots.measures, spots.audio_prompt_url, spots.image_prompt_url, spots.notes_prompt, spots.text_prompt, spots.current_tempo, spots.last_practiced, spots.stage_started, spots.priority,
    pieces.title AS piece_title
FROM spots
INNER JOIN pieces ON pieces.id = spots.piece_id
WHERE pieces.user_id = ?1 AND spots.priority < 0
ORDER BY spots.priority
`

type ListHighPrioritySpotsRow struct {
	ID             string         `json:"id"`
	PieceID        string         `json:"pieceId"`
	Name           string         `json:"name"`
	Idx            int64          `json:"idx"`
	Stage          string         `json:"stage"`
	Measures       sql.NullString `json:"measures"`
	AudioPromptUrl string         `json:"audioPromptUrl"`
	ImagePromptUrl string         `json:"imagePromptUrl"`
	NotesPrompt    string         `json:"notesPrompt"`
	TextPrompt     string         `json:"textPrompt"`
	CurrentTempo   sql.NullInt64  `json:"currentTempo"`
	LastPracticed  sql.NullInt64  `json:"lastPracticed"`
	StageStarted   sql.NullInt64  `json:"stageStarted"`
	Priority       int64          `json:"priority"`
	PieceTitle     string         `json:"pieceTitle"`
}

func (q *Queries) ListHighPrioritySpots(ctx context.Context, userID string) ([]ListHighPrioritySpotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listHighPrioritySpots, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHighPrioritySpotsRow
	for rows.Next() {
		var i ListHighPrioritySpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.PieceID,
			&i.Name,
			&i.Idx,
			&i.Stage,
			&i.Measures,
			&i.AudioPromptUrl,
			&i.ImagePromptUrl,
			&i.NotesPrompt,
			&i.TextPrompt,
			&i.CurrentTempo,
			&i.LastPracticed,
			&i.StageStarted,
			&i.Priority,
			&i.PieceTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPieceSpots = `-- name: ListPieceSpots :many
SELECT
    spots.id, spots.piece_id, spots.name, spots.idx, spots.stage, spots.measures, spots.audio_prompt_url, spots.image_prompt_url, spots.notes_prompt, spots.text_prompt, spots.current_tempo, spots.last_practiced, spots.stage_started, spots.priority,
    pieces.title AS piece_title
FROM spots
INNER JOIN pieces ON pieces.id = spots.piece_id
WHERE piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?1 AND pieces.id = ?2 LIMIT 1)
ORDER BY spots.idx
`

type ListPieceSpotsParams struct {
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

type ListPieceSpotsRow struct {
	ID             string         `json:"id"`
	PieceID        string         `json:"pieceId"`
	Name           string         `json:"name"`
	Idx            int64          `json:"idx"`
	Stage          string         `json:"stage"`
	Measures       sql.NullString `json:"measures"`
	AudioPromptUrl string         `json:"audioPromptUrl"`
	ImagePromptUrl string         `json:"imagePromptUrl"`
	NotesPrompt    string         `json:"notesPrompt"`
	TextPrompt     string         `json:"textPrompt"`
	CurrentTempo   sql.NullInt64  `json:"currentTempo"`
	LastPracticed  sql.NullInt64  `json:"lastPracticed"`
	StageStarted   sql.NullInt64  `json:"stageStarted"`
	Priority       int64          `json:"priority"`
	PieceTitle     string         `json:"pieceTitle"`
}

func (q *Queries) ListPieceSpots(ctx context.Context, arg ListPieceSpotsParams) ([]ListPieceSpotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPieceSpots, arg.UserID, arg.PieceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPieceSpotsRow
	for rows.Next() {
		var i ListPieceSpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.PieceID,
			&i.Name,
			&i.Idx,
			&i.Stage,
			&i.Measures,
			&i.AudioPromptUrl,
			&i.ImagePromptUrl,
			&i.NotesPrompt,
			&i.TextPrompt,
			&i.CurrentTempo,
			&i.LastPracticed,
			&i.StageStarted,
			&i.Priority,
			&i.PieceTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteSpotToExtraRepeat = `-- name: PromoteSpotToExtraRepeat :exec
UPDATE spots
SET
    stage = CASE WHEN stage = 'repeat' THEN 'extra_repeat' ELSE stage END,
    stage_started = CASE WHEN stage = 'repeat' THEN unixepoch('now') ELSE stage_started END,
    last_practiced = unixepoch('now')
WHERE spots.id = ?1 AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type PromoteSpotToExtraRepeatParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

func (q *Queries) PromoteSpotToExtraRepeat(ctx context.Context, arg PromoteSpotToExtraRepeatParams) error {
	_, err := q.db.ExecContext(ctx, promoteSpotToExtraRepeat, arg.SpotID, arg.UserID, arg.PieceID)
	return err
}

const promoteSpotToInterleave = `-- name: PromoteSpotToInterleave :exec
UPDATE spots
SET
    stage = CASE WHEN stage = 'random' THEN 'interleave' ELSE stage END,
    stage_started = CASE WHEN stage = 'random' THEN unixepoch('now') ELSE stage_started END,
    last_practiced = unixepoch('now')
WHERE spots.id = ?1 AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type PromoteSpotToInterleaveParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

func (q *Queries) PromoteSpotToInterleave(ctx context.Context, arg PromoteSpotToInterleaveParams) error {
	_, err := q.db.ExecContext(ctx, promoteSpotToInterleave, arg.SpotID, arg.UserID, arg.PieceID)
	return err
}

const promoteSpotToRandom = `-- name: PromoteSpotToRandom :exec
UPDATE spots
SET
    stage = CASE WHEN stage = 'repeat' OR stage = 'extra_repeat' THEN 'random' ELSE stage END,
    stage_started = CASE WHEN stage = 'repeat' OR stage = 'extra_repeat' THEN unixepoch('now') ELSE stage_started END,
    last_practiced = unixepoch('now')
WHERE spots.id = ?1 AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2 AND pieces.id = ?3 LIMIT 1)
`

type PromoteSpotToRandomParams struct {
	SpotID  string `json:"spotId"`
	UserID  string `json:"userId"`
	PieceID string `json:"pieceId"`
}

func (q *Queries) PromoteSpotToRandom(ctx context.Context, arg PromoteSpotToRandomParams) error {
	_, err := q.db.ExecContext(ctx, promoteSpotToRandom, arg.SpotID, arg.UserID, arg.PieceID)
	return err
}

const updateSpot = `-- name: UpdateSpot :exec
UPDATE spots
SET
    name = ?,
    idx = ?,
    stage = ?,
    stage_started = ?,
    audio_prompt_url = ?,
    image_prompt_url = ?,
    notes_prompt = ?,
    text_prompt = ?,
    current_tempo = ?,
    measures = ?
WHERE spots.id = ? AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ? AND pieces.id = ? LIMIT 1)
`

type UpdateSpotParams struct {
	Name           string         `json:"name"`
	Idx            int64          `json:"idx"`
	Stage          string         `json:"stage"`
	StageStarted   sql.NullInt64  `json:"stageStarted"`
	AudioPromptUrl string         `json:"audioPromptUrl"`
	ImagePromptUrl string         `json:"imagePromptUrl"`
	NotesPrompt    string         `json:"notesPrompt"`
	TextPrompt     string         `json:"textPrompt"`
	CurrentTempo   sql.NullInt64  `json:"currentTempo"`
	Measures       sql.NullString `json:"measures"`
	SpotID         string         `json:"spotId"`
	UserID         string         `json:"userId"`
	PieceID        string         `json:"pieceId"`
}

func (q *Queries) UpdateSpot(ctx context.Context, arg UpdateSpotParams) error {
	_, err := q.db.ExecContext(ctx, updateSpot,
		arg.Name,
		arg.Idx,
		arg.Stage,
		arg.StageStarted,
		arg.AudioPromptUrl,
		arg.ImagePromptUrl,
		arg.NotesPrompt,
		arg.TextPrompt,
		arg.CurrentTempo,
		arg.Measures,
		arg.SpotID,
		arg.UserID,
		arg.PieceID,
	)
	return err
}

const updateSpotPracticed = `-- name: UpdateSpotPracticed :exec
UPDATE spots
SET last_practiced = unixepoch('now')
WHERE spots.id = ?1 AND spots.piece_id IN (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?2)
`

type UpdateSpotPracticedParams struct {
	SpotID string `json:"spotId"`
	UserID string `json:"userId"`
}

func (q *Queries) UpdateSpotPracticed(ctx context.Context, arg UpdateSpotPracticedParams) error {
	_, err := q.db.ExecContext(ctx, updateSpotPracticed, arg.SpotID, arg.UserID)
	return err
}

const updateSpotPriority = `-- name: UpdateSpotPriority :exec
UPDATE spots
SET
    priority = ?1
WHERE spots.id = ?2 AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ?3 AND pieces.id = ?4 LIMIT 1)
`

type UpdateSpotPriorityParams struct {
	Priority int64  `json:"priority"`
	SpotID   string `json:"spotId"`
	UserID   string `json:"userId"`
	PieceID  string `json:"pieceId"`
}

func (q *Queries) UpdateSpotPriority(ctx context.Context, arg UpdateSpotPriorityParams) error {
	_, err := q.db.ExecContext(ctx, updateSpotPriority,
		arg.Priority,
		arg.SpotID,
		arg.UserID,
		arg.PieceID,
	)
	return err
}

const updateTextPrompt = `-- name: UpdateTextPrompt :one
UPDATE spots
SET
    text_prompt = ?
WHERE spots.id = ? AND piece_id = (SELECT pieces.id FROM pieces WHERE pieces.user_id = ? AND pieces.id = ? LIMIT 1)
RETURNING id, piece_id, name, idx, stage, measures, audio_prompt_url, image_prompt_url, notes_prompt, text_prompt, current_tempo, last_practiced, stage_started, priority
`

type UpdateTextPromptParams struct {
	TextPrompt string `json:"textPrompt"`
	SpotID     string `json:"spotId"`
	UserID     string `json:"userId"`
	PieceID    string `json:"pieceId"`
}

func (q *Queries) UpdateTextPrompt(ctx context.Context, arg UpdateTextPromptParams) (Spot, error) {
	row := q.db.QueryRowContext(ctx, updateTextPrompt,
		arg.TextPrompt,
		arg.SpotID,
		arg.UserID,
		arg.PieceID,
	)
	var i Spot
	err := row.Scan(
		&i.ID,
		&i.PieceID,
		&i.Name,
		&i.Idx,
		&i.Stage,
		&i.Measures,
		&i.AudioPromptUrl,
		&i.ImagePromptUrl,
		&i.NotesPrompt,
		&i.TextPrompt,
		&i.CurrentTempo,
		&i.LastPracticed,
		&i.StageStarted,
		&i.Priority,
	)
	return i, err
}
