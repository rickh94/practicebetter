// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: reading.sql

package db

import (
	"context"
	"database/sql"
)

const completeReading = `-- name: CompleteReading :one
UPDATE reading
SET completed = true
WHERE id = ? AND user_id = ?
RETURNING id, title, info, completed, composer, user_id
`

type CompleteReadingParams struct {
	ID     string `json:"id"`
	UserID string `json:"userId"`
}

func (q *Queries) CompleteReading(ctx context.Context, arg CompleteReadingParams) (Reading, error) {
	row := q.db.QueryRowContext(ctx, completeReading, arg.ID, arg.UserID)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Info,
		&i.Completed,
		&i.Composer,
		&i.UserID,
	)
	return i, err
}

const countUserReadingItems = `-- name: CountUserReadingItems :one
SELECT COUNT(*) FROM reading WHERE user_id = ? LIMIT 1
`

func (q *Queries) CountUserReadingItems(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserReadingItems, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSightReadingItem = `-- name: CreateSightReadingItem :one
INSERT INTO reading (
    id,
    title,
    info,
    composer,
    user_id
) VALUES (?, ?, ?, ?, ?)
RETURNING id, title, info, completed, composer, user_id
`

type CreateSightReadingItemParams struct {
	ID       string         `json:"id"`
	Title    string         `json:"title"`
	Info     sql.NullString `json:"info"`
	Composer sql.NullString `json:"composer"`
	UserID   string         `json:"userId"`
}

func (q *Queries) CreateSightReadingItem(ctx context.Context, arg CreateSightReadingItemParams) (Reading, error) {
	row := q.db.QueryRowContext(ctx, createSightReadingItem,
		arg.ID,
		arg.Title,
		arg.Info,
		arg.Composer,
		arg.UserID,
	)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Info,
		&i.Completed,
		&i.Composer,
		&i.UserID,
	)
	return i, err
}

const deleteReadingItem = `-- name: DeleteReadingItem :exec
DELETE FROM reading
WHERE id = ? AND user_id = ?
`

type DeleteReadingItemParams struct {
	ID     string `json:"id"`
	UserID string `json:"userId"`
}

func (q *Queries) DeleteReadingItem(ctx context.Context, arg DeleteReadingItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteReadingItem, arg.ID, arg.UserID)
	return err
}

const getReadingByID = `-- name: GetReadingByID :one
SELECT id, title, info, completed, composer, user_id
FROM reading
WHERE id = ?1 AND user_id = ?2
LIMIT 1
`

type GetReadingByIDParams struct {
	ReadingID string `json:"readingId"`
	UserID    string `json:"userId"`
}

func (q *Queries) GetReadingByID(ctx context.Context, arg GetReadingByIDParams) (Reading, error) {
	row := q.db.QueryRowContext(ctx, getReadingByID, arg.ReadingID, arg.UserID)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Info,
		&i.Completed,
		&i.Composer,
		&i.UserID,
	)
	return i, err
}

const listAllUserReadingItems = `-- name: ListAllUserReadingItems :many
SELECT id, title, info, completed, composer, user_id
FROM reading
WHERE user_id = ?
ORDER BY title
`

func (q *Queries) ListAllUserReadingItems(ctx context.Context, userID string) ([]Reading, error) {
	rows, err := q.db.QueryContext(ctx, listAllUserReadingItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reading
	for rows.Next() {
		var i Reading
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Info,
			&i.Completed,
			&i.Composer,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncompleteUserReadingItems = `-- name: ListIncompleteUserReadingItems :many
SELECT id, title, info, completed, composer, user_id
FROM reading
WHERE user_id = ? AND completed = false
ORDER BY title
`

func (q *Queries) ListIncompleteUserReadingItems(ctx context.Context, userID string) ([]Reading, error) {
	rows, err := q.db.QueryContext(ctx, listIncompleteUserReadingItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reading
	for rows.Next() {
		var i Reading
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Info,
			&i.Completed,
			&i.Composer,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaginatedUserReadingItems = `-- name: ListPaginatedUserReadingItems :many
SELECT id, title, info, completed, composer, user_id
FROM reading
WHERE user_id = ?
ORDER BY title
LIMIT ? OFFSET ?
`

type ListPaginatedUserReadingItemsParams struct {
	UserID string `json:"userId"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListPaginatedUserReadingItems(ctx context.Context, arg ListPaginatedUserReadingItemsParams) ([]Reading, error) {
	rows, err := q.db.QueryContext(ctx, listPaginatedUserReadingItems, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reading
	for rows.Next() {
		var i Reading
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Info,
			&i.Completed,
			&i.Composer,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReading = `-- name: UpdateReading :one
UPDATE reading
SET
    title = ?,
    info = ?,
    composer = ?
WHERE id = ? AND user_id = ?
RETURNING id, title, info, completed, composer, user_id
`

type UpdateReadingParams struct {
	Title    string         `json:"title"`
	Info     sql.NullString `json:"info"`
	Composer sql.NullString `json:"composer"`
	ID       string         `json:"id"`
	UserID   string         `json:"userId"`
}

func (q *Queries) UpdateReading(ctx context.Context, arg UpdateReadingParams) (Reading, error) {
	row := q.db.QueryRowContext(ctx, updateReading,
		arg.Title,
		arg.Info,
		arg.Composer,
		arg.ID,
		arg.UserID,
	)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Info,
		&i.Completed,
		&i.Composer,
		&i.UserID,
	)
	return i, err
}
